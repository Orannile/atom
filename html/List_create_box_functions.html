
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>List of building and simulation cell manipulation functions</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-12-09"><meta name="DC.source" content="List_create_box_functions.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>List of building and simulation cell manipulation functions</h1><div><ol><li><a href="add2atom(XYZ_labels,XYZ_data,varargin)">add2atom(XYZ_labels,XYZ_data,varargin)</a> %&nbsp;This function appends so-called XYZ atomtype labels and XYZ data to an existing atom struct</li><li><a href="center_atom(atom,Box_dim,resname,dim)">center_atom(atom,Box_dim,resname,dim)</a> %&nbsp;This function centers the atom with respect to the resname molecule</li><li><a href="composition_atom(atom)">composition_atom(atom)</a> %&nbsp;This function looks at the composition of the atom struct</li><li><a href="concatenate_atom(atom_1,atom_2)">concatenate_atom(atom_1,atom_2)</a> %&nbsp;This function concatenats atom sections.</li><li><a href="condense_atom(atom,Box_dim,s)">condense_atom(atom,Box_dim,s)</a> %&nbsp;This function tries to minimize the box size and remove gaps between molids?</li><li><a href="copy_atom(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)">copy_atom(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)</a> % This function copies and translates atoms in the atom struct</li><li><a href="copy_type(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)">copy_type(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)</a> % This function copies and translates types in the atom struct</li><li><a href="create_atom(type,resname,limits,nmax,varargin)">create_atom(type,resname,limits,nmax,varargin)</a> % Creates new atoms, good for adding ions to a system. Creates atoms within a certain region defined by <a href="limits">limits</a></li><li><a href="create_grid_atom(atom_label,nM,limits,dim,varargin)">create_grid_atom(atom_label,nM,limits,dim,varargin)</a> % This old function puts ions on a grid plane and adds it to an atom struct</li><li><a href="draw_box_atom(Box_dim,LineColor,LineThickness)">draw_box_atom(Box_dim,LineColor,LineThickness)</a> % Draws a box</li><li><a href="duplicate_atom(atom,molID)">duplicate_atom(atom,molID)</a> %&nbsp;This function duplicates residue with molid MolID</li><li><a href="element_atom(atom,varargin)">element_atom(atom,varargin)</a> % Converts atomtypes to element types. This function replaces the atomtypes names with the element names</li><li><a href="frac2atom(atom,Box_dim,angleparam,angletype)">frac2atom(atom,Box_dim,angleparam,angletype)</a> % This function transforms fractional coordinates to cartesian</li><li><a href="grid2atom(atom_label,nM,limits,dim,varargin)">grid2atom(atom_label,nM,limits,dim,varargin)</a> %&nbsp; grid2atom.m - This puts particles such as ions on a 2D grid (i.e. a plane)&gt; % and adds it to an atom struct</li><li><a href="insert_atom(atom_in,limits,rotate,r,maxsol,solute_atom,varargin)">insert_atom(atom_in,limits,rotate,r,maxsol,solute_atom,varargin)</a> % - This inserts a molecule from a structure file into a region defined by <a href="limits">limits</a> with a atom (molecule)&gt; % structure</li><li><a href="mass_atom(atom)">mass_atom(atom)</a> % This function fetches the mass for each atomtype and put it into atom.mass</li><li><a href="merge_atom(atom1,Box1,atom2,type,Atom_label,r)">merge_atom(atom1,Box1,atom2,type,Atom_label,r)</a> % This function returns the atom2 struct with atoms in the atom2 struct with a distance r [1x1 or 1x2] away from the atoms in the atom1 struct. There is also a possibility to use a twin-range cutoff approach (suitable for OH2), by setting r(2) to a smaller value than r(1)</li><li><a href="molid_rotate(atom,Box_dim,MolID,rotate_dim)">molid_rotate(atom,Box_dim,MolID,rotate_dim)</a> %&nbsp;This function rotate the atom randomly</li><li><a href="molid_translate(atom,trans_vec,MolID)">molid_translate(atom,trans_vec,MolID)</a> % This translates a certain molid</li><li><a href="orto_atom(atom,Box_dim)">orto_atom(atom,Box_dim)</a> %&nbsp;This transforms a triclinic atom struct to an orthogonal atom struct. Box_dim must look like [lx ly lz 0 0 xy 0 xz yz]</li><li><a href="overwrite_atom(In_atom,atomtype,resname)">overwrite_atom(In_atom,atomtype,resname)</a> % This function overwrites the atom struct information with new information&nbsp;</li><li><a href="place_atom(atom,position)">place_atom(atom,position)</a> % This function places the atom struct according to the position vector called position, trying to use the COM of the molecule</li><li><a href="position_molid(atom,position_vec,MolID)">position_molid(atom,position_vec,MolID)</a> %&nbsp;This function movies a molid (COM)&gt; % to a certain position</li><li><a href="reorder_atom_gro(atom,atomlist,Box_dim,filename_out)">reorder_atom_gro(atom,atomlist,Box_dim,filename_out)</a> %&nbsp;This function reorders the atoms in a .gro file</li><li><a href="replicate_atom(atom,Box_dim,replicate)">replicate_atom(atom,Box_dim,replicate)</a> % This replicates the atom struct and the orthogonal box dimensions</li><li><a href="resname_atom(atom)">resname_atom(atom)</a> % This function tries to guess the resname of all atom types</li><li><a href="rotate_atom(atom,Box_dim,alfa,beta,gamma)">rotate_atom(atom,Box_dim,alfa,beta,gamma)</a> %&nbsp;This function rotate the atom randomly</li><li><a href="scale_atom(atom,scale_vec,Box_dim,Resname)">scale_atom(atom,scale_vec,Box_dim,Resname)</a> %&nbsp;This function scales the coordinates in the atom struct</li><li><a href="slice_atom(atom,limits,invert)">slice_atom(atom,limits,invert)</a> %&nbsp;This function checks if the coordinates for each time record in XYZ_data is within the specified limits, and if not sets the x,y,z to nan,nan,nan.</li><li><a href="slice_molid(atom,limits,invert)">slice_molid(atom,limits,invert)</a> %&nbsp;This function checks if the coordinates is within the specified limits, and if not sets the x,y,z to nan,nan,nan.</li><li><a href="solvate_atom(limits,density,r,maxsol,solute_atom,varargin)">solvate_atom(limits,density,r,maxsol,solute_atom,varargin)</a> % This function generates a certain region defined by <a href="limits">limits</a> with a solvent structure of density <a href="density">density</a></li><li><a href="substitute_atom(atom,Box_dim,NumOctSubst,O1,O2,minO2O2_dist,varargin)">substitute_atom(atom,Box_dim,NumOctSubst,O1,O2,minO2O2_dist,varargin)</a> % This scripts performs isomorphous substitution, by replacing some O1-&gt;O2 atomtypes and optionally T1-&gt;T2 atomtypes</li><li><a href="translate_atom(atom,trans_vec,Resname)">translate_atom(atom,trans_vec,Resname)</a> % This translates the resname by a vector</li><li><a href="translate_molid(atom,trans_vec,molid)">translate_molid(atom,trans_vec,molid)</a> %&nbsp;This translates the molid by a vector</li><li><a href="triclinic_atom(atom,Box_dim,angleparam,angletype)">triclinic_atom(atom,Box_dim,angleparam,angletype)</a> %&nbsp; triclinic_atom.m - This transforms an orthogonal atom struct to a triclinic with the angles alfa, beta, gamma or tilt factors xy, xz, yz</li><li><a href="unwrap_atom(atom,Box_dim,dim)">unwrap_atom(atom,Box_dim,dim)</a> %&nbsp;This function unwraps the atom struct along the dimension dim</li><li><a href="update_atom(atom)">update_atom(atom)</a> %&nbsp;This function updates the molid index and the atoms index in the atom struct</li><li><a href="wrap_atom(atom,Box_dim)">wrap_atom(atom,Box_dim)</a> % This wraps the atoms into the orthogonal box</li><li><a href="Wrap_Coord_func(XYZ_data,Box_dim)">Wrap_Coord_func(XYZ_data,Box_dim)</a> % This is an old function that wraps atoms 'sticking out' back into the box</li><li><a href="wrap_molid(atom,Box_dim)">wrap_molid(atom,Box_dim)</a> % This function wraps the atom struct into the box</li><li><a href="xyz2atom(XYZ_labels,XYZ_data,Box_dim,resname,in_atom)">xyz2atom(XYZ_labels,XYZ_data,Box_dim,resname,in_atom)</a> % This function can be used to add XYZ data (like from a .xyz structure file)to the atom struct format</li></ol></div><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% List of building and simulation cell manipulation functions
% # <add2atom(XYZ_labels,XYZ_data,varargin)> % This function appends so-called XYZ atomtype labels and XYZ data to an existing atom struct
% # <center_atom(atom,Box_dim,resname,dim)> % This function centers the atom with respect to the resname molecule
% # <composition_atom(atom)> % This function looks at the composition of the atom struct
% # <concatenate_atom(atom_1,atom_2)> % This function concatenats atom sections.
% # <condense_atom(atom,Box_dim,s)> % This function tries to minimize the box size and remove gaps between molids?
% # <copy_atom(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)> % This function copies and translates atoms in the atom struct
% # <copy_type(atom,atomtype,new_atomtype,new_resname,trans_vec,varargin)> % This function copies and translates types in the atom struct
% # <create_atom(type,resname,limits,nmax,varargin)> % Creates new atoms, good for adding ions to a system. Creates atoms within a certain region defined by <limits>
% # <create_grid_atom(atom_label,nM,limits,dim,varargin)> % This old function puts ions on a grid plane and adds it to an atom struct
% # <draw_box_atom(Box_dim,LineColor,LineThickness)> % Draws a box
% # <duplicate_atom(atom,molID)> % This function duplicates residue with molid MolID
% # <element_atom(atom,varargin)> % Converts atomtypes to element types. This function replaces the atomtypes names with the element names
% # <frac2atom(atom,Box_dim,angleparam,angletype)> % This function transforms fractional coordinates to cartesian
% # <grid2atom(atom_label,nM,limits,dim,varargin)> %  grid2atom.m - This puts particles such as ions on a 2D grid (i.e. a plane)> % and adds it to an atom struct
% # <insert_atom(atom_in,limits,rotate,r,maxsol,solute_atom,varargin)> % - This inserts a molecule from a structure file into a region defined by <limits> with a atom (molecule)> % structure
% # <mass_atom(atom)> % This function fetches the mass for each atomtype and put it into atom.mass
% # <merge_atom(atom1,Box1,atom2,type,Atom_label,r)> % This function returns the atom2 struct with atoms in the atom2 struct with a distance r [1x1 or 1x2] away from the atoms in the atom1 struct. There is also a possibility to use a twin-range cutoff approach (suitable for OH2), by setting r(2) to a smaller value than r(1)
% # <molid_rotate(atom,Box_dim,MolID,rotate_dim)> % This function rotate the atom randomly
% # <molid_translate(atom,trans_vec,MolID)> % This translates a certain molid
% # <orto_atom(atom,Box_dim)> % This transforms a triclinic atom struct to an orthogonal atom struct. Box_dim must look like [lx ly lz 0 0 xy 0 xz yz]
% # <overwrite_atom(In_atom,atomtype,resname)> % This function overwrites the atom struct information with new information 
% # <place_atom(atom,position)> % This function places the atom struct according to the position vector called position, trying to use the COM of the molecule
% # <position_molid(atom,position_vec,MolID)> % This function movies a molid (COM)> % to a certain position
% # <reorder_atom_gro(atom,atomlist,Box_dim,filename_out)> % This function reorders the atoms in a .gro file
% # <replicate_atom(atom,Box_dim,replicate)> % This replicates the atom struct and the orthogonal box dimensions
% # <resname_atom(atom)> % This function tries to guess the resname of all atom types
% # <rotate_atom(atom,Box_dim,alfa,beta,gamma)> % This function rotate the atom randomly
% # <scale_atom(atom,scale_vec,Box_dim,Resname)> % This function scales the coordinates in the atom struct
% # <slice_atom(atom,limits,invert)> % This function checks if the coordinates for each time record in XYZ_data is within the specified limits, and if not sets the x,y,z to nan,nan,nan.
% # <slice_molid(atom,limits,invert)> % This function checks if the coordinates is within the specified limits, and if not sets the x,y,z to nan,nan,nan.
% # <solvate_atom(limits,density,r,maxsol,solute_atom,varargin)> % This function generates a certain region defined by <limits> with a solvent structure of density <density>
% # <substitute_atom(atom,Box_dim,NumOctSubst,O1,O2,minO2O2_dist,varargin)> % This scripts performs isomorphous substitution, by replacing some O1->O2 atomtypes and optionally T1->T2 atomtypes
% # <translate_atom(atom,trans_vec,Resname)> % This translates the resname by a vector
% # <translate_molid(atom,trans_vec,molid)> % This translates the molid by a vector
% # <triclinic_atom(atom,Box_dim,angleparam,angletype)> %  triclinic_atom.m - This transforms an orthogonal atom struct to a triclinic with the angles alfa, beta, gamma or tilt factors xy, xz, yz
% # <unwrap_atom(atom,Box_dim,dim)> % This function unwraps the atom struct along the dimension dim
% # <update_atom(atom)> % This function updates the molid index and the atoms index in the atom struct
% # <wrap_atom(atom,Box_dim)> % This wraps the atoms into the orthogonal box
% # <Wrap_Coord_func(XYZ_data,Box_dim)> % This is an old function that wraps atoms 'sticking out' back into the box
% # <wrap_molid(atom,Box_dim)> % This function wraps the atom struct into the box
% # <xyz2atom(XYZ_labels,XYZ_data,Box_dim,resname,in_atom)> % This function can be used to add XYZ data (like from a .xyz structure file)to the atom struct format


##### SOURCE END #####
--></body></html>